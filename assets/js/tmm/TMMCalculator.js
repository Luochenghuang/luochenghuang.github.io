/**
 * Transfer Matrix Method (TMM) calculator for multilayer structures.
 * Copyright (c) 2025, Luocheng Huang
 * @module TMMCalculator
 */
function calculateLayerMatrix(t,m,a,l,h,i){const p=1e-9*a,e=1e-9*l,u=2*Math.PI/e,c=u*Math.sin(h*Math.PI/180),y=math.complex(t,m);let o;o=math.sqrt(math.subtract(math.multiply(math.multiply(y,y),u*u),math.complex(c*c,0)));const n=math.cos(math.multiply(o,math.complex(p,0))),r=math.sin(math.multiply(o,math.complex(p,0)));let d,x,s,M;if("TE"===i)d=n,x=math.divide(math.multiply(r,math.complex(1,0)),o),s=math.multiply(math.multiply(r,o),math.complex(-1,0)),M=n;else{const t=math.multiply(y,y);d=n,x=math.divide(math.multiply(r,t),o),s=math.multiply(math.divide(math.multiply(r,o),t),math.complex(-1,0)),M=n}return[[d,x],[s,M]]}function multiplyMatrices(t,m){return[[math.add(math.multiply(t[0][0],m[0][0]),math.multiply(t[0][1],m[1][0])),math.add(math.multiply(t[0][0],m[0][1]),math.multiply(t[0][1],m[1][1]))],[math.add(math.multiply(t[1][0],m[0][0]),math.multiply(t[1][1],m[1][0])),math.add(math.multiply(t[1][0],m[0][1]),math.multiply(t[1][1],m[1][1]))]]}function inverseMatrix(t){const m=math.subtract(math.multiply(t[0][0],t[1][1]),math.multiply(t[0][1],t[1][0])),a=t[1][1],l=math.multiply(t[0][1],math.complex(-1,0)),h=math.multiply(t[1][0],math.complex(-1,0)),i=t[0][0];return[[math.divide(i,m),math.divide(l,m)],[math.divide(h,m),math.divide(a,m)]]}export function calculateRT(t,m,a,l){let h=[[math.complex(1,0),math.complex(0,0)],[math.complex(0,0),math.complex(1,0)]];const i=[];if(l.TE&&i.push("TE"),l.TM&&i.push("TM"),0===i.length)return{R:0,T:0,A:1};let p=math.complex(0,0),e=math.complex(0,0);for(const l of i){h=[[math.complex(1,0),math.complex(0,0)],[math.complex(0,0),math.complex(1,0)]];for(let i=t.length-1;i>=0;i--){const p=t[i];h=multiplyMatrices(h,calculateLayerMatrix(p.n,p.k,p.d||0,m,a,l))}h=inverseMatrix(h);const i=math.complex(t[0].n,t[0].k),u=math.complex(t[t.length-1].n,t[t.length-1].k),c=2*Math.PI/(1e-9*m),y=c*Math.sin(a*Math.PI/180),o=math.sqrt(math.subtract(math.multiply(math.multiply(i,i),c*c),math.complex(y*y,0))),n=math.sqrt(math.subtract(math.multiply(math.multiply(u,u),c*c),math.complex(y*y,0))),r=math.multiply(h[0][0],math.multiply(o,math.multiply(u,u))),d=math.multiply(h[1][1],math.multiply(n,math.multiply(i,i))),x=math.multiply(h[1][0],math.multiply(math.multiply(u,u),math.multiply(i,i))),s=math.multiply(h[0][1],math.multiply(o,n)),M=math.subtract(math.add(r,d),math.multiply(math.complex(0,1),math.subtract(x,s))),v=math.add(math.multiply(math.complex(-1,0),r),math.multiply(math.complex(1,0),d)),f=math.divide(math.subtract(v,math.multiply(math.complex(0,1),math.add(x,s))),M),b=math.divide(math.multiply(math.complex(-2,0),math.multiply(math.multiply(i,u),o)),M);p=math.add(p,math.multiply(f,math.conj(f))),e=math.add(e,math.multiply(b,math.conj(b)))}p=math.divide(p,i.length),e=math.divide(e,i.length);const u=1-math.abs(p)-math.abs(e);return{R:math.re(p),T:math.abs(e),A:Math.max(0,u)}};export function generateWavelengthArray(t,m,a){const l=(m-t)/(a-1);return Array.from({length:a},(m,a)=>t+a*l)};