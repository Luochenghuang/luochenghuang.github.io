/**
 * Transfer Matrix Method (TMM) calculator for multilayer structures.
 * Copyright (c) 2025, Luocheng Huang
 * @module TMMCalculator
 */
function calculateLayerMatrix(t,m,a,l,h,i){const e=1e-9*a,p=1e-9*l,u=2*Math.PI/p,c=u*Math.sin(h*Math.PI/180),o=math.complex(t,m);let y;y=math.sqrt(math.subtract(math.multiply(math.multiply(o,o),u*u),math.complex(c*c,0)));const d=math.cos(math.multiply(y,math.complex(e,0))),n=math.sin(math.multiply(y,math.complex(e,0)));let r,x,s,v;if("TE"===i)r=d,x=math.divide(math.multiply(n,math.complex(1,0)),y),s=math.multiply(math.divide(n,y),math.complex(-1,0)),v=d;else{const t=math.multiply(o,o);r=d,x=math.divide(math.multiply(n,t),y),s=math.multiply(math.divide(math.multiply(n,y),t),math.complex(-1,0)),v=d}return[[r,x],[s,v]]}function multiplyMatrices(t,m){return[[math.add(math.multiply(t[0][0],m[0][0]),math.multiply(t[0][1],m[1][0])),math.add(math.multiply(t[0][0],m[0][1]),math.multiply(t[0][1],m[1][1]))],[math.add(math.multiply(t[1][0],m[0][0]),math.multiply(t[1][1],m[1][0])),math.add(math.multiply(t[1][0],m[0][1]),math.multiply(t[1][1],m[1][1]))]]}function inverseMatrix(t){const m=math.subtract(math.multiply(t[0][0],t[1][1]),math.multiply(t[0][1],t[1][0])),a=t[1][1],l=math.multiply(t[0][1],math.complex(-1,0)),h=math.multiply(t[1][0],math.complex(-1,0)),i=t[0][0];return[[math.divide(i,m),math.divide(l,m)],[math.divide(h,m),math.divide(a,m)]]}export function calculateRT(t,m,a,l){let h=[[math.complex(1,0),math.complex(0,0)],[math.complex(0,0),math.complex(1,0)]];const i=[];if(l.TE&&i.push("TE"),l.TM&&i.push("TM"),0===i.length)return{R:0,T:0,A:1};let e=math.complex(0,0),p=math.complex(0,0);for(const l of i){h=[[math.complex(1,0),math.complex(0,0)],[math.complex(0,0),math.complex(1,0)]];for(let i=t.length-1;i>=0;i--){const e=t[i];h=multiplyMatrices(h,calculateLayerMatrix(e.n,e.k,e.d||0,m,a,l))}h=inverseMatrix(h);const i="TE"===l?math.complex(1,0):math.complex(t[0].n,t[0].k),u="TE"===l?math.complex(1,0):math.complex(t[t.length-1].n,t[t.length-1].k),c=2*Math.PI/(1e-9*m),o=c*Math.sin(a*Math.PI/180),y=math.sqrt(math.subtract(math.multiply(math.multiply(i,i),c*c),math.complex(o*o,0))),d=math.sqrt(math.subtract(math.multiply(math.multiply(u,u),c*c),math.complex(o*o,0))),n=math.multiply(h[0][0],math.multiply(y,math.multiply(u,u))),r=math.multiply(h[1][1],math.multiply(d,math.multiply(i,i))),x=math.multiply(h[1][0],math.multiply(math.multiply(u,u),math.multiply(i,i))),s=math.multiply(h[0][1],math.multiply(y,d)),v=math.subtract(math.add(n,r),math.multiply(math.complex(0,1),math.subtract(x,s))),M=math.add(math.multiply(math.complex(-1,0),n),math.multiply(math.complex(1,0),r)),f=math.divide(math.add(M,math.multiply(math.complex(0,1),math.add(x,s))),v),T=math.divide(math.multiply(math.complex(-2,0),math.multiply(math.multiply(i,u),y)),v);e=math.add(e,math.multiply(f,math.conj(f))),p=math.add(p,math.multiply(T,math.conj(T)))}e=math.divide(e,i.length),p=math.divide(p,i.length);const u=1-math.abs(e)-math.abs(p);return{R:math.re(e),T:math.abs(p),A:Math.max(0,u)}};export function generateWavelengthArray(t,m,a){const l=(m-t)/(a-1);return Array.from({length:a},(m,a)=>t+a*l)};